#region Using Statements
using System;
using System.Threading;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Audio;
#endregion

namespace GameStateManagement
{
    /// <summary>
    /// This screen implements the actual game logic. It is just a
    /// placeholder to get the idea across: you'll probably want to
    /// put some more interesting gameplay in here!
    /// </summary>
    class ForestScreen : MiniGameScreen
    {
        #region Fields

        Texture2D background;
        Texture2D seedTexture;
        Texture2D treeTexture;

        Texture2D ballNormal;
        Ball ball;

        SpriteFont gameFont;

        Bucket bucket;

        SoundEffect treeSound;

        TreeObject[,] treeGrid;

        int numberOfTrees = 1;

        public bool won = false;

        #endregion

        #region Initialization


        /// <summary>
        /// Constructor.
        /// </summary>
        public ForestScreen(GameScreenPosition gameScreenPosition)
        {
            ScreenPosition = gameScreenPosition;
        }


        /// <summary>
        /// Load graphics content for the game.
        /// </summary>
        public void LoadContent(ContentManager content, ScreenManager screenManager)
        {
            gameFont = content.Load<SpriteFont>("gamefont");
            background = content.Load<Texture2D>("ForestScreenBackGround");
            treeTexture = content.Load<Texture2D>("TreeObject");
            seedTexture = content.Load<Texture2D>("SeedObject");

            treeSound = content.Load<SoundEffect>("Tree");

            ballNormal = content.Load<Texture2D>("NormalWater");

            // Initialize bucket
            bucket = new Bucket(Resolution.GetMiniGameResolution());
            ball = new Ball(ballNormal, bucket.GetBounds(), Resolution.GetMiniGameResolution());

            int gridWidth = Resolution.GetMiniGameResolution().Width / treeTexture.Width;
            int gridHeight = (int)(Resolution.GetMiniGameResolution().Height * .75 / treeTexture.Height);
            treeGrid = new TreeObject[gridWidth, gridHeight];
            treeGrid[gridWidth / 2 - 1, gridHeight / 2 - 1] = new TreeObject(TreeObjectType.Tree, treeTexture, GetTreeObjectPosition(gridWidth / 2 - 1, gridHeight / 2 - 1));
            Spread(gridWidth / 2 - 1, gridHeight / 2 - 1);
            screenManager.Game.ResetElapsedTime();
        }


        /// <summary>
        /// Unload graphics content used by the game.
        /// </summary>
        public void UnloadContent()
        {
        }


        #endregion

        #region Update and Draw

        /// <summary>
        /// Updates the state of the game. This method checks the GameScreen.IsActive
        /// property, so the game will stop updating when the pause menu is active,
        /// or if you tab away to a different application.
        /// </summary>
        public void Update(GameTime gameTime)
        {
            ball.Update(gameTime);
            HandleTreeCollisions();

            if (IsActive())
            {
                if (!ball.IsMoving) //If the ball hasn't been shot yet
                    ball.Position = new Vector2(bucket.position.X + bucket.GetBounds().Width / 2, bucket.position.Y);
                ball.PaddleCollision(bucket);
                bucket.Update(gameTime);
            }
            UpdateTreeObjects(gameTime);

            if ( numberOfTrees >= Level.TreesToWin )
            {
                OnWin();
            }
        }

        private void HandleTreeCollisions()
        {
            for (int i = 0; i < treeGrid.GetLength(0); i++)
            {
                for (int j = 0; j < treeGrid.GetLength(1); j++)
                {
                    if (IsValidTreeObjectPosition(i, j) && treeGrid[i, j] != null)
                    {
                        if (ball.CollidesWithObject(treeGrid[i, j].Bounds) && treeGrid[i, j].Type != TreeObjectType.Tree)
                        {
                            ball.LoseHealth();
                            treeGrid[i, j].OnCollision(Bucket.Type);

                            treeSound.Play();

                            if (!ball.IsAlive())
                            {
                                ball.SetInStartPosition(bucket.GetBounds());
                            }
                            if (!treeGrid[i, j].IsAlive())
                            {
                                treeGrid[i, j] = new TreeObject(TreeObjectType.Tree, treeTexture, GetTreeObjectPosition(i, j));
                                Spread(i, j);
                                ball.SetInStartPosition(bucket.GetBounds());
                            }
                        }
                        else if (TranslatePosition(ball.Position).Y + (ball.RectangleBounds.Height * screenScale.Y) >= TranslatePosition(new Vector2(0, Resolution.GetMiniGameResolution().Height)).Y)
                        {
                            ball.SetInStartPosition(bucket.GetBounds());
                        }
                    }
                }
            }
        }

        private void UpdateTreeObjects(GameTime gameTime)
        {
            for (int i = 0; i < treeGrid.GetLength(0); i++)
            {
                for (int j = 0; j < treeGrid.GetLength(1); j++)
                {
                    if (IsValidTreeObjectPosition(i, j) && treeGrid[i, j] != null)
                    {
                        treeGrid[i, j].Update(gameTime);
                    }
                }
            }
        }

        private bool IsValidTreeObjectPosition(int x, int y)
        {
            if (y % 2 == 1) //shorter row
                return (x >= 0 && x < treeGrid.GetLength(0) - 1 && y >= 0 && y < treeGrid.GetLength(1));
            else
                return (x >= 0 && x < treeGrid.GetLength(0) && y >= 0 && y < treeGrid.GetLength(1));
        }

        private Vector2 GetTreeObjectPosition(int x, int y)
        {
            if (y % 2 == 1) //shorter row
                return new Vector2(x * treeTexture.Width + (treeTexture.Width / 2), y * treeTexture.Height);
            else
                return new Vector2(x * treeTexture.Width, y * treeTexture.Height);
        }

        private void Spread(int x, int y)
        {
            AddTreeObject(x - 1, y);
            AddTreeObject(x + 1, y);
            if (y % 2 == 0) //longer row
                x--;
            AddTreeObject(x, y - 1);
            AddTreeObject(x, y + 1);
            AddTreeObject(x + 1, y - 1);
            AddTreeObject(x + 1, y + 1);
        }

        private void AddTreeObject(int x, int y)
        {
            if (IsValidTreeObjectPosition(x, y) && treeGrid[x, y] == null)
                treeGrid[x, y] = new TreeObject(TreeObjectType.Seed, seedTexture, GetTreeObjectPosition(x, y));
        }

        private void OnWin()
        {
            won = true;
            //screenManager.AddScreen(new GameWinMenuScreen(), ControllingPlayer);
            //Level Cleared
        }

        /// <summary>
        /// Lets the game respond to player input. Unlike the Update method,
        /// this will only be called when the gameplay screen is active.
        /// </summary>
        public void HandleInput(InputState input)
        {
            if (input == null)
                throw new ArgumentNullException("input");

            KeyboardState keyboardState = input.CurrentKeyboardStates[0];
            GamePadState gamePadState = input.CurrentGamePadStates[0];

            bool gamePadDisconnected = !input.CurrentGamePadStates[0].IsConnected &&
                                       input.GamePadWasConnected[0];

            if (input.IsNewKeyPress(Keys.Space) && !ball.IsMoving && bucket.CanShoot())
            {
                bucket.DecreaseWaterCount(Ball.MaxHealth);
                ball.SetInMotion(bucket);
            }
        }


        /// <summary>
        /// Draws the gameplay screen.
        /// </summary>
        public void Draw(GameTime gameTime, SpriteBatch spriteBatch)
        {
            spriteBatch.Begin(SpriteSortMode.Immediate, BlendState.AlphaBlend, null, null, null, null, Resolution.getTransformationMatrix());

            spriteBatch.Draw(background, screen, Color.White);
            DrawTreeObjects(gameTime, spriteBatch);
            if (ball.IsMoving || IsActive())
            {
                ball.Draw(spriteBatch, TranslatePosition(ball.Position), SpriteScale);
                ball.DrawHealthCount(spriteBatch, TranslatePosition(ball.Position), SpriteScale, gameFont);
            }
            if (IsActive()) //Draw bucket if current window is active
            {
                Vector2 translatedBucketPosition = TranslatePosition(bucket.position);
                bucket.Draw(spriteBatch, translatedBucketPosition, SpriteScale);
                bucket.DrawWaterCount(spriteBatch, translatedBucketPosition, SpriteScale, gameFont);
            }
            spriteBatch.End();
        }

        private void DrawTreeObjects(GameTime gameTime, SpriteBatch spriteBatch)
        {
            for (int i = 0; i < treeGrid.GetLength(0); i++)
            {
                for (int j = 0; j < treeGrid.GetLength(1); j++)
                {
                    if (treeGrid[i, j] != null)
                    {
                        treeGrid[i, j].Draw(spriteBatch, TranslatePosition(GetTreeObjectPosition(i, j)), SpriteScale);
                        treeGrid[i, j].DrawSeedCount(spriteBatch, TranslatePosition(GetTreeObjectPosition(i, j)), SpriteScale, gameFont);
                    }
                }
            }

        }


        #endregion
    }
}

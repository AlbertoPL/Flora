#region Using Statements
using System;
using System.Threading;
using System.Diagnostics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
#endregion

namespace GameStateManagement
{
    /// <summary>
    /// This screen implements the actual game logic. It is just a
    /// placeholder to get the idea across: you'll probably want to
    /// put some more interesting gameplay in here!
    /// </summary>
    class FireScreen : MiniGameScreen
    {
        #region Fields

        Texture2D background;
        public Texture2D invincFireTexture;
        public Texture2D fireTexture;
        Texture2D deathLine;
        
        Texture2D ballNormal;
        Ball ball;

        SpriteFont gameFont;

        Bucket bucket;

        FireObject[,] fireGrid;
        public bool lost;

        #endregion

        #region Initialization


        /// <summary>
        /// Constructor.
        /// </summary>
        public FireScreen(GameScreenPosition gameScreenPosition)
        {
            ScreenPosition = gameScreenPosition;
            lost = false;
        }


        /// <summary>
        /// Load graphics content for the game.
        /// </summary>
        public void LoadContent(ContentManager content, ScreenManager screenManager)
        {
            gameFont = content.Load<SpriteFont>("gamefont");
            background = content.Load<Texture2D>("FireScreenBackGround");
            fireTexture = content.Load<Texture2D>("FireObject");
            invincFireTexture = content.Load<Texture2D>("InvincFireObject");

            ballNormal = content.Load<Texture2D>("NormalWater");

            // Initialize bucket
            bucket = new Bucket(Resolution.GetMiniGameResolution());
            ball = new Ball(ballNormal, bucket.GetBounds(), Resolution.GetMiniGameResolution());


            fireGrid = Level.FireGrid;
            screenManager.Game.ResetElapsedTime();
            deathLine = new Texture2D(screenManager.GraphicsDevice, 1, 1, false, SurfaceFormat.Color);
            deathLine.SetData(new[] { Color.White });
        }



        /// <summary>
        /// Unload graphics content used by the game.
        /// </summary>
        public void UnloadContent()
        {
        }


        #endregion

        #region Update and Draw

        /// <summary>
        /// Updates the state of the game. This method checks the GameScreen.IsActive
        /// property, so the game will stop updating when the pause menu is active,
        /// or if you tab away to a different application.
        /// </summary>
        public void Update(GameTime gameTime)
        {
            ball.Update(gameTime);
            HandleFireCollisions();
            if (IsActive())
            {
                if (!ball.IsMoving) //If the ball hasn't been shot yet
                    ball.Position = new Vector2(bucket.position.X + bucket.GetBounds().Width/2, bucket.position.Y);
                ball.PaddleCollision(bucket);
                bucket.Update(gameTime);
            }
            UpdateFireObjects(gameTime);
        }

        private void HandleFireCollisions()
        {
            for (int i = 0; i < fireGrid.GetLength(0); i++)
            {
                for (int j = 0; j < fireGrid.GetLength(1); j++)
                {
                    if (IsValidFireObjectPosition(i, j) && fireGrid[i, j] != null)
                    {
                        if (ball.CollidesWithObject(fireGrid[i, j].Bounds) && fireGrid[i, j].Type != FireObjectType.Invincible)
                        {
                            ball.LoseHealth();
                            if (!ball.IsAlive())
                            {
                                ball.SetInStartPosition(bucket.GetBounds());
                            }
                            if (fireGrid[i, j].OnCollision(Bucket.Type))
                            {
                                Spread(i, j);
                                ball.SetInStartPosition(bucket.GetBounds());
                            }
                            if(!fireGrid[i, j].IsAlive())
                                fireGrid[i, j] = null;
                        }
                        else if (TranslatePosition(ball.Position).Y + (ball.RectangleBounds.Height * screenScale.Y) >= TranslatePosition(new Vector2(0, Resolution.GetMiniGameResolution().Height)).Y)
                        {
                            ball.SetInStartPosition(bucket.GetBounds());
                        }
                    }
                }
            }
        }

        private void UpdateFireObjects(GameTime gameTime)
        {
            for (int i = 0; i < fireGrid.GetLength(0); i++)
            {
                for (int j = 0; j < fireGrid.GetLength(1); j++)
                {
                    if (IsValidFireObjectPosition(i, j) && fireGrid[i, j] != null)
                    {
                        if (fireGrid[i, j].Update(gameTime))
                            Spread(i, j);
                        if (j == fireGrid.GetLength(1) - 1) //If fire reaches the 'bottom'
                            OnLose();
                    }
                }
            }
        }

        private bool IsValidFireObjectPosition(int x, int y)
        {
            if (y % 2 == 1) //shorter row
                return (x >= 0 && x < fireGrid.GetLength(0) - 1 && y >= 0 && y < fireGrid.GetLength(1));
            else
                return (x >= 0 && x < fireGrid.GetLength(0) && y >= 0 && y < fireGrid.GetLength(1));
        }

        private Vector2 GetFireObjectPosition(int x, int y)
        {
            if (y % 2 == 1) //shorter row
                return new Vector2(x * fireTexture.Width + (fireTexture.Width / 2), y * fireTexture.Height);
            else
                return new Vector2(x * fireTexture.Width, y * fireTexture.Height);
        }

        private void Spread(int x, int y)
        {
            AddFireObject(x - 1, y);
            AddFireObject(x + 1, y);
            if (y % 2 == 0) //longer row
                x--;
            AddFireObject(x, y - 1);
            AddFireObject(x, y + 1);
            AddFireObject(x + 1, y - 1);
            AddFireObject(x + 1, y + 1);
        }

        private void AddFireObject(int x, int y)
        {
            if(IsValidFireObjectPosition(x, y) && fireGrid[x, y] == null)
                fireGrid[x, y] = new FireObject(FireObjectType.Normal, fireTexture, GetFireObjectPosition(x, y));
        }

        private void OnLose()
        {
            lost = true;
            //screenManager.AddScreen(new GameOverMenuScreen(), ControllingPlayer);
            //Game over
        }

        /// <summary>
        /// Lets the game respond to player input. Unlike the Update method,
        /// this will only be called when the gameplay screen is active.
        /// </summary>
        public void HandleInput(InputState input)
        {
            if (input == null)
                throw new ArgumentNullException("input");

            KeyboardState keyboardState = input.CurrentKeyboardStates[0];
            GamePadState gamePadState = input.CurrentGamePadStates[0];

            bool gamePadDisconnected = !input.CurrentGamePadStates[0].IsConnected &&
                                       input.GamePadWasConnected[0];

            if (input.IsNewKeyPress(Keys.Space) && !ball.IsMoving && bucket.CanShoot())
            {
                bucket.DecreaseWaterCount(Ball.MaxHealth);
                ball.SetInMotion(bucket);
            }
        }


        /// <summary>
        /// Draws the gameplay screen.
        /// </summary>
        public void Draw(GameTime gameTime, SpriteBatch spriteBatch)
        {
            spriteBatch.Begin(SpriteSortMode.Immediate, BlendState.AlphaBlend, null, null, null, null, Resolution.getTransformationMatrix());

            spriteBatch.Draw(background, screen, Color.White);
            DrawFireObjects(gameTime, spriteBatch);
            if (ball.IsMoving || IsActive())
            {
                ball.Draw(spriteBatch, TranslatePosition(ball.Position), SpriteScale);
                ball.DrawHealthCount(spriteBatch, TranslatePosition(ball.Position), SpriteScale, gameFont);
            }
            if (IsActive()) //Draw bucket if current window is active
            {
                Vector2 translatedBucketPosition = TranslatePosition(bucket.position);
                bucket.Draw(spriteBatch, translatedBucketPosition, SpriteScale);
                bucket.DrawWaterCount(spriteBatch, translatedBucketPosition, SpriteScale, gameFont);
            }
            DrawLine(spriteBatch, deathLine, 1, Color.Black, TranslatePosition(new Vector2(0, Resolution.GetMiniGameResolution().Height - (4 * fireTexture.Height / .75f))), TranslatePosition(new Vector2(Resolution.GetMiniGameResolution().Width, Resolution.GetMiniGameResolution().Height - (4 * fireTexture.Height / .75f))));
            spriteBatch.End();
        }

        private void DrawLine(SpriteBatch batch, Texture2D blank,
              float width, Color color, Vector2 point1, Vector2 point2)
        {
            float angle = (float)Math.Atan2(point2.Y - point1.Y, point2.X - point1.X);
            float length = Vector2.Distance(point1, point2);

            batch.Draw(blank, point1, null, color,
                       angle, Vector2.Zero, new Vector2(length, width),
                       SpriteEffects.None, 0);
        }

        private void DrawFireObjects(GameTime gameTime, SpriteBatch spriteBatch)
        {
            for (int i = 0; i < fireGrid.GetLength(0); i++)
            {
                for (int j = 0; j < fireGrid.GetLength(1); j++)
                {
                    if (fireGrid[i, j] != null)
                    {
                        fireGrid[i, j].Draw(spriteBatch, TranslatePosition(GetFireObjectPosition(i, j)), SpriteScale);
                    }
                }
            }

        }


        #endregion
    }
}
